import {
  __commonJS,
  __publicField,
  __require,
  __toESM
} from "./chunk-2LSFTFF7.js";

// browser-external:crypto
var require_crypto = __commonJS({
  "browser-external:crypto"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_2, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "crypto" has been externalized for browser compatibility. Cannot access "crypto.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/crypto-js/core.js
var require_core = __commonJS({
  "node_modules/crypto-js/core.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory();
      } else if (typeof define === "function" && define.amd) {
        define([], factory);
      } else {
        root.CryptoJS = factory();
      }
    })(exports, function() {
      var CryptoJS = CryptoJS || function(Math2, undefined) {
        var crypto;
        if (typeof window !== "undefined" && window.crypto) {
          crypto = window.crypto;
        }
        if (typeof self !== "undefined" && self.crypto) {
          crypto = self.crypto;
        }
        if (typeof globalThis !== "undefined" && globalThis.crypto) {
          crypto = globalThis.crypto;
        }
        if (!crypto && typeof window !== "undefined" && window.msCrypto) {
          crypto = window.msCrypto;
        }
        if (!crypto && typeof global !== "undefined" && global.crypto) {
          crypto = global.crypto;
        }
        if (!crypto && typeof __require === "function") {
          try {
            crypto = require_crypto();
          } catch (err) {
          }
        }
        var cryptoSecureRandomInt = function() {
          if (crypto) {
            if (typeof crypto.getRandomValues === "function") {
              try {
                return crypto.getRandomValues(new Uint32Array(1))[0];
              } catch (err) {
              }
            }
            if (typeof crypto.randomBytes === "function") {
              try {
                return crypto.randomBytes(4).readInt32LE();
              } catch (err) {
              }
            }
          }
          throw new Error("Native crypto module could not be used to get secure random number.");
        };
        var create = Object.create || function() {
          function F2() {
          }
          return function(obj) {
            var subtype;
            F2.prototype = obj;
            subtype = new F2();
            F2.prototype = null;
            return subtype;
          };
        }();
        var C = {};
        var C_lib = C.lib = {};
        var Base = C_lib.Base = function() {
          return {
            /**
             * Creates a new object that inherits from this object.
             *
             * @param {Object} overrides Properties to copy into the new object.
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         field: 'value',
             *
             *         method: function () {
             *         }
             *     });
             */
            extend: function(overrides) {
              var subtype = create(this);
              if (overrides) {
                subtype.mixIn(overrides);
              }
              if (!subtype.hasOwnProperty("init") || this.init === subtype.init) {
                subtype.init = function() {
                  subtype.$super.init.apply(this, arguments);
                };
              }
              subtype.init.prototype = subtype;
              subtype.$super = this;
              return subtype;
            },
            /**
             * Extends this object and runs the init method.
             * Arguments to create() will be passed to init().
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var instance = MyType.create();
             */
            create: function() {
              var instance = this.extend();
              instance.init.apply(instance, arguments);
              return instance;
            },
            /**
             * Initializes a newly created object.
             * Override this method to add some logic when your objects are created.
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         init: function () {
             *             // ...
             *         }
             *     });
             */
            init: function() {
            },
            /**
             * Copies properties into this object.
             *
             * @param {Object} properties The properties to mix in.
             *
             * @example
             *
             *     MyType.mixIn({
             *         field: 'value'
             *     });
             */
            mixIn: function(properties) {
              for (var propertyName in properties) {
                if (properties.hasOwnProperty(propertyName)) {
                  this[propertyName] = properties[propertyName];
                }
              }
              if (properties.hasOwnProperty("toString")) {
                this.toString = properties.toString;
              }
            },
            /**
             * Creates a copy of this object.
             *
             * @return {Object} The clone.
             *
             * @example
             *
             *     var clone = instance.clone();
             */
            clone: function() {
              return this.init.prototype.extend(this);
            }
          };
        }();
        var WordArray = C_lib.WordArray = Base.extend({
          /**
           * Initializes a newly created word array.
           *
           * @param {Array} words (Optional) An array of 32-bit words.
           * @param {number} sigBytes (Optional) The number of significant bytes in the words.
           *
           * @example
           *
           *     var wordArray = CryptoJS.lib.WordArray.create();
           *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
           *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
           */
          init: function(words, sigBytes) {
            words = this.words = words || [];
            if (sigBytes != undefined) {
              this.sigBytes = sigBytes;
            } else {
              this.sigBytes = words.length * 4;
            }
          },
          /**
           * Converts this word array to a string.
           *
           * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
           *
           * @return {string} The stringified word array.
           *
           * @example
           *
           *     var string = wordArray + '';
           *     var string = wordArray.toString();
           *     var string = wordArray.toString(CryptoJS.enc.Utf8);
           */
          toString: function(encoder) {
            return (encoder || Hex).stringify(this);
          },
          /**
           * Concatenates a word array to this word array.
           *
           * @param {WordArray} wordArray The word array to append.
           *
           * @return {WordArray} This word array.
           *
           * @example
           *
           *     wordArray1.concat(wordArray2);
           */
          concat: function(wordArray) {
            var thisWords = this.words;
            var thatWords = wordArray.words;
            var thisSigBytes = this.sigBytes;
            var thatSigBytes = wordArray.sigBytes;
            this.clamp();
            if (thisSigBytes % 4) {
              for (var i = 0; i < thatSigBytes; i++) {
                var thatByte = thatWords[i >>> 2] >>> 24 - i % 4 * 8 & 255;
                thisWords[thisSigBytes + i >>> 2] |= thatByte << 24 - (thisSigBytes + i) % 4 * 8;
              }
            } else {
              for (var j2 = 0; j2 < thatSigBytes; j2 += 4) {
                thisWords[thisSigBytes + j2 >>> 2] = thatWords[j2 >>> 2];
              }
            }
            this.sigBytes += thatSigBytes;
            return this;
          },
          /**
           * Removes insignificant bits.
           *
           * @example
           *
           *     wordArray.clamp();
           */
          clamp: function() {
            var words = this.words;
            var sigBytes = this.sigBytes;
            words[sigBytes >>> 2] &= 4294967295 << 32 - sigBytes % 4 * 8;
            words.length = Math2.ceil(sigBytes / 4);
          },
          /**
           * Creates a copy of this word array.
           *
           * @return {WordArray} The clone.
           *
           * @example
           *
           *     var clone = wordArray.clone();
           */
          clone: function() {
            var clone = Base.clone.call(this);
            clone.words = this.words.slice(0);
            return clone;
          },
          /**
           * Creates a word array filled with random bytes.
           *
           * @param {number} nBytes The number of random bytes to generate.
           *
           * @return {WordArray} The random word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.lib.WordArray.random(16);
           */
          random: function(nBytes) {
            var words = [];
            for (var i = 0; i < nBytes; i += 4) {
              words.push(cryptoSecureRandomInt());
            }
            return new WordArray.init(words, nBytes);
          }
        });
        var C_enc = C.enc = {};
        var Hex = C_enc.Hex = {
          /**
           * Converts a word array to a hex string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The hex string.
           *
           * @static
           *
           * @example
           *
           *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var hexChars = [];
            for (var i = 0; i < sigBytes; i++) {
              var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
              hexChars.push((bite >>> 4).toString(16));
              hexChars.push((bite & 15).toString(16));
            }
            return hexChars.join("");
          },
          /**
           * Converts a hex string to a word array.
           *
           * @param {string} hexStr The hex string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
           */
          parse: function(hexStr) {
            var hexStrLength = hexStr.length;
            var words = [];
            for (var i = 0; i < hexStrLength; i += 2) {
              words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << 24 - i % 8 * 4;
            }
            return new WordArray.init(words, hexStrLength / 2);
          }
        };
        var Latin1 = C_enc.Latin1 = {
          /**
           * Converts a word array to a Latin1 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The Latin1 string.
           *
           * @static
           *
           * @example
           *
           *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var latin1Chars = [];
            for (var i = 0; i < sigBytes; i++) {
              var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
              latin1Chars.push(String.fromCharCode(bite));
            }
            return latin1Chars.join("");
          },
          /**
           * Converts a Latin1 string to a word array.
           *
           * @param {string} latin1Str The Latin1 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
           */
          parse: function(latin1Str) {
            var latin1StrLength = latin1Str.length;
            var words = [];
            for (var i = 0; i < latin1StrLength; i++) {
              words[i >>> 2] |= (latin1Str.charCodeAt(i) & 255) << 24 - i % 4 * 8;
            }
            return new WordArray.init(words, latin1StrLength);
          }
        };
        var Utf8 = C_enc.Utf8 = {
          /**
           * Converts a word array to a UTF-8 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The UTF-8 string.
           *
           * @static
           *
           * @example
           *
           *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
           */
          stringify: function(wordArray) {
            try {
              return decodeURIComponent(escape(Latin1.stringify(wordArray)));
            } catch (e2) {
              throw new Error("Malformed UTF-8 data");
            }
          },
          /**
           * Converts a UTF-8 string to a word array.
           *
           * @param {string} utf8Str The UTF-8 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
           */
          parse: function(utf8Str) {
            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
          }
        };
        var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
          /**
           * Resets this block algorithm's data buffer to its initial state.
           *
           * @example
           *
           *     bufferedBlockAlgorithm.reset();
           */
          reset: function() {
            this._data = new WordArray.init();
            this._nDataBytes = 0;
          },
          /**
           * Adds new data to this block algorithm's buffer.
           *
           * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
           *
           * @example
           *
           *     bufferedBlockAlgorithm._append('data');
           *     bufferedBlockAlgorithm._append(wordArray);
           */
          _append: function(data) {
            if (typeof data == "string") {
              data = Utf8.parse(data);
            }
            this._data.concat(data);
            this._nDataBytes += data.sigBytes;
          },
          /**
           * Processes available data blocks.
           *
           * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
           *
           * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
           *
           * @return {WordArray} The processed data.
           *
           * @example
           *
           *     var processedData = bufferedBlockAlgorithm._process();
           *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
           */
          _process: function(doFlush) {
            var processedWords;
            var data = this._data;
            var dataWords = data.words;
            var dataSigBytes = data.sigBytes;
            var blockSize = this.blockSize;
            var blockSizeBytes = blockSize * 4;
            var nBlocksReady = dataSigBytes / blockSizeBytes;
            if (doFlush) {
              nBlocksReady = Math2.ceil(nBlocksReady);
            } else {
              nBlocksReady = Math2.max((nBlocksReady | 0) - this._minBufferSize, 0);
            }
            var nWordsReady = nBlocksReady * blockSize;
            var nBytesReady = Math2.min(nWordsReady * 4, dataSigBytes);
            if (nWordsReady) {
              for (var offset = 0; offset < nWordsReady; offset += blockSize) {
                this._doProcessBlock(dataWords, offset);
              }
              processedWords = dataWords.splice(0, nWordsReady);
              data.sigBytes -= nBytesReady;
            }
            return new WordArray.init(processedWords, nBytesReady);
          },
          /**
           * Creates a copy of this object.
           *
           * @return {Object} The clone.
           *
           * @example
           *
           *     var clone = bufferedBlockAlgorithm.clone();
           */
          clone: function() {
            var clone = Base.clone.call(this);
            clone._data = this._data.clone();
            return clone;
          },
          _minBufferSize: 0
        });
        var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
          /**
           * Configuration options.
           */
          cfg: Base.extend(),
          /**
           * Initializes a newly created hasher.
           *
           * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
           *
           * @example
           *
           *     var hasher = CryptoJS.algo.SHA256.create();
           */
          init: function(cfg) {
            this.cfg = this.cfg.extend(cfg);
            this.reset();
          },
          /**
           * Resets this hasher to its initial state.
           *
           * @example
           *
           *     hasher.reset();
           */
          reset: function() {
            BufferedBlockAlgorithm.reset.call(this);
            this._doReset();
          },
          /**
           * Updates this hasher with a message.
           *
           * @param {WordArray|string} messageUpdate The message to append.
           *
           * @return {Hasher} This hasher.
           *
           * @example
           *
           *     hasher.update('message');
           *     hasher.update(wordArray);
           */
          update: function(messageUpdate) {
            this._append(messageUpdate);
            this._process();
            return this;
          },
          /**
           * Finalizes the hash computation.
           * Note that the finalize operation is effectively a destructive, read-once operation.
           *
           * @param {WordArray|string} messageUpdate (Optional) A final message update.
           *
           * @return {WordArray} The hash.
           *
           * @example
           *
           *     var hash = hasher.finalize();
           *     var hash = hasher.finalize('message');
           *     var hash = hasher.finalize(wordArray);
           */
          finalize: function(messageUpdate) {
            if (messageUpdate) {
              this._append(messageUpdate);
            }
            var hash = this._doFinalize();
            return hash;
          },
          blockSize: 512 / 32,
          /**
           * Creates a shortcut function to a hasher's object interface.
           *
           * @param {Hasher} hasher The hasher to create a helper for.
           *
           * @return {Function} The shortcut function.
           *
           * @static
           *
           * @example
           *
           *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
           */
          _createHelper: function(hasher) {
            return function(message, cfg) {
              return new hasher.init(cfg).finalize(message);
            };
          },
          /**
           * Creates a shortcut function to the HMAC's object interface.
           *
           * @param {Hasher} hasher The hasher to use in this HMAC helper.
           *
           * @return {Function} The shortcut function.
           *
           * @static
           *
           * @example
           *
           *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
           */
          _createHmacHelper: function(hasher) {
            return function(message, key) {
              return new C_algo.HMAC.init(hasher, key).finalize(message);
            };
          }
        });
        var C_algo = C.algo = {};
        return C;
      }(Math);
      return CryptoJS;
    });
  }
});

// node_modules/crypto-js/enc-hex.js
var require_enc_hex = __commonJS({
  "node_modules/crypto-js/enc-hex.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      return CryptoJS.enc.Hex;
    });
  }
});

// node_modules/crypto-js/sha1.js
var require_sha1 = __commonJS({
  "node_modules/crypto-js/sha1.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C.algo;
        var W2 = [];
        var SHA1 = C_algo.SHA1 = Hasher.extend({
          _doReset: function() {
            this._hash = new WordArray.init([
              1732584193,
              4023233417,
              2562383102,
              271733878,
              3285377520
            ]);
          },
          _doProcessBlock: function(M2, offset) {
            var H2 = this._hash.words;
            var a2 = H2[0];
            var b2 = H2[1];
            var c = H2[2];
            var d = H2[3];
            var e2 = H2[4];
            for (var i = 0; i < 80; i++) {
              if (i < 16) {
                W2[i] = M2[offset + i] | 0;
              } else {
                var n = W2[i - 3] ^ W2[i - 8] ^ W2[i - 14] ^ W2[i - 16];
                W2[i] = n << 1 | n >>> 31;
              }
              var t = (a2 << 5 | a2 >>> 27) + e2 + W2[i];
              if (i < 20) {
                t += (b2 & c | ~b2 & d) + 1518500249;
              } else if (i < 40) {
                t += (b2 ^ c ^ d) + 1859775393;
              } else if (i < 60) {
                t += (b2 & c | b2 & d | c & d) - 1894007588;
              } else {
                t += (b2 ^ c ^ d) - 899497514;
              }
              e2 = d;
              d = c;
              c = b2 << 30 | b2 >>> 2;
              b2 = a2;
              a2 = t;
            }
            H2[0] = H2[0] + a2 | 0;
            H2[1] = H2[1] + b2 | 0;
            H2[2] = H2[2] + c | 0;
            H2[3] = H2[3] + d | 0;
            H2[4] = H2[4] + e2 | 0;
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math.floor(nBitsTotal / 4294967296);
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
            data.sigBytes = dataWords.length * 4;
            this._process();
            return this._hash;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });
        C.SHA1 = Hasher._createHelper(SHA1);
        C.HmacSHA1 = Hasher._createHmacHelper(SHA1);
      })();
      return CryptoJS.SHA1;
    });
  }
});

// node_modules/@upstash/redis/chunk-DFUAPYBG.mjs
var import_enc_hex = __toESM(require_enc_hex(), 1);
var import_sha1 = __toESM(require_sha1(), 1);
var Ne = Object.defineProperty;
var Le = (s, n) => {
  for (var t in n)
    Ne(s, t, { get: n[t], enumerable: true });
};
var ze = {};
Le(ze, { UpstashError: () => u, UrlError: () => Oe });
var u = class extends Error {
  constructor(n) {
    super(n), this.name = "UpstashError";
  }
};
var Oe = class extends Error {
  constructor(n) {
    super(`Upstash Redis client was passed an invalid URL. You should pass the URL together with https. Received: "${n}". `), this.name = "UrlError";
  }
};
var Me = class {
  constructor(n) {
    __publicField(this, "baseUrl");
    __publicField(this, "headers");
    __publicField(this, "options");
    __publicField(this, "retry");
    var _a, _b, _c;
    if (this.options = { backend: (_a = n.options) == null ? void 0 : _a.backend, agent: n.agent, responseEncoding: n.responseEncoding ?? "base64", cache: n.cache, signal: n.signal, keepAlive: n.keepAlive ?? true }, this.baseUrl = n.baseUrl.replace(/\/$/, ""), !/^https?:\/\/[^\s/$.?#].[^\s]*$/.test(this.baseUrl))
      throw new Oe(this.baseUrl);
    this.headers = { "Content-Type": "application/json", ...n.headers }, this.options.responseEncoding === "base64" && (this.headers["Upstash-Encoding"] = "base64"), typeof (n == null ? void 0 : n.retry) == "boolean" && (n == null ? void 0 : n.retry) === false ? this.retry = { attempts: 1, backoff: () => 0 } : this.retry = { attempts: ((_b = n == null ? void 0 : n.retry) == null ? void 0 : _b.retries) ?? 5, backoff: ((_c = n == null ? void 0 : n.retry) == null ? void 0 : _c.backoff) ?? ((o2) => Math.exp(o2) * 50) };
  }
  mergeTelemetry(n) {
    function t(o2, m, r) {
      return r && (o2[m] ? o2[m] = [o2[m], r].join(",") : o2[m] = r), o2;
    }
    this.headers = t(this.headers, "Upstash-Telemetry-Runtime", n.runtime), this.headers = t(this.headers, "Upstash-Telemetry-Platform", n.platform), this.headers = t(this.headers, "Upstash-Telemetry-Sdk", n.sdk);
  }
  async request(n) {
    var _a, _b, _c, _d;
    let t = { cache: this.options.cache, method: "POST", headers: this.headers, body: JSON.stringify(n.body), keepalive: this.options.keepAlive, agent: (_a = this.options) == null ? void 0 : _a.agent, signal: this.options.signal, backend: (_b = this.options) == null ? void 0 : _b.backend }, o2 = null, m = null;
    for (let a2 = 0; a2 <= this.retry.attempts; a2++)
      try {
        o2 = await fetch([this.baseUrl, ...n.path ?? []].join("/"), t);
        break;
      } catch (i) {
        if ((_c = this.options.signal) == null ? void 0 : _c.aborted) {
          let p = new Blob([JSON.stringify({ result: this.options.signal.reason ?? "Aborted" })]), d = { status: 200, statusText: this.options.signal.reason ?? "Aborted" };
          o2 = new Response(p, d);
          break;
        }
        m = i, await new Promise((p) => setTimeout(p, this.retry.backoff(a2)));
      }
    if (!o2)
      throw m ?? new Error("Exhausted all retries");
    let r = await o2.json();
    if (!o2.ok)
      throw new u(`${r.error}, command was: ${JSON.stringify(n.body)}`);
    return ((_d = this.options) == null ? void 0 : _d.responseEncoding) === "base64" ? Array.isArray(r) ? r.map(({ result: i, error: p }) => ({ result: ke(i), error: p })) : { result: ke(r.result), error: r.error } : r;
  }
};
function ve(s) {
  let n = "";
  try {
    let t = atob(s), o2 = t.length, m = new Uint8Array(o2);
    for (let r = 0; r < o2; r++)
      m[r] = t.charCodeAt(r);
    n = new TextDecoder().decode(m);
  } catch {
    n = s;
  }
  return n;
}
function ke(s) {
  let n;
  switch (typeof s) {
    case "undefined":
      return s;
    case "number": {
      n = s;
      break;
    }
    case "object": {
      Array.isArray(s) ? n = s.map((t) => typeof t == "string" ? ve(t) : Array.isArray(t) ? t.map(ke) : t) : n = null;
      break;
    }
    case "string": {
      n = s === "OK" ? "OK" : ve(s);
      break;
    }
    default:
      break;
  }
  return n;
}
function Se(s, n) {
  let t = s;
  return t.autoPipelineExecutor || (t.autoPipelineExecutor = new Re(t)), new Proxy(t, { get: (o2, m) => m === "pipelineCounter" ? o2.autoPipelineExecutor.pipelineCounter : m === "json" ? Se(o2, true) : m in o2 && !(m in o2.autoPipelineExecutor.pipeline) ? o2[m] : (n ? typeof o2.autoPipelineExecutor.pipeline.json[m] == "function" : typeof o2.autoPipelineExecutor.pipeline[m] == "function") ? (...i) => o2.autoPipelineExecutor.withAutoPipeline((p) => {
    n ? p.json[m](...i) : p[m](...i);
  }) : o2.autoPipelineExecutor.pipeline[m] });
}
var Re = class {
  constructor(n) {
    __publicField(this, "pipelinePromises", /* @__PURE__ */ new WeakMap());
    __publicField(this, "activePipeline", null);
    __publicField(this, "indexInCurrentPipeline", 0);
    __publicField(this, "redis");
    __publicField(this, "pipeline");
    __publicField(this, "pipelineCounter", 0);
    this.redis = n, this.pipeline = n.pipeline();
  }
  async withAutoPipeline(n) {
    let t = this.activePipeline || this.redis.pipeline();
    this.activePipeline || (this.activePipeline = t, this.indexInCurrentPipeline = 0);
    let o2 = this.indexInCurrentPipeline++;
    return n(t), (await this.deferExecution().then(() => {
      if (!this.pipelinePromises.has(t)) {
        let a2 = t.exec();
        this.pipelineCounter += 1, this.pipelinePromises.set(t, a2), this.activePipeline = null;
      }
      return this.pipelinePromises.get(t);
    }))[o2];
  }
  async deferExecution() {
    return await Promise.resolve(), await Promise.resolve();
  }
};
function Pe(s) {
  let n = Array.isArray(s) ? s.map((t) => {
    try {
      return Pe(t);
    } catch {
      return t;
    }
  }) : JSON.parse(s);
  return typeof n == "number" && n.toString() !== s ? s : n;
}
function Ee(s) {
  try {
    return Pe(s);
  } catch {
    return s;
  }
}
function h(s) {
  return [s[0], ...Ee(s.slice(1))];
}
var Ge = (s) => {
  switch (typeof s) {
    case "string":
    case "number":
    case "boolean":
      return s;
    default:
      return JSON.stringify(s);
  }
};
var e = class {
  constructor(n, t) {
    __publicField(this, "command");
    __publicField(this, "serialize");
    __publicField(this, "deserialize");
    if (this.serialize = Ge, this.deserialize = typeof (t == null ? void 0 : t.automaticDeserialization) > "u" || t.automaticDeserialization ? (t == null ? void 0 : t.deserialize) ?? Ee : (o2) => o2, this.command = n.map((o2) => this.serialize(o2)), t == null ? void 0 : t.latencyLogging) {
      let o2 = this.exec.bind(this);
      this.exec = async (m) => {
        let r = performance.now(), a2 = await o2(m), p = (performance.now() - r).toFixed(2);
        return console.log(`Latency for \x1B[38;2;19;185;39m${this.command[0].toString().toUpperCase()}\x1B[0m: \x1B[38;2;0;255;255m${p} ms\x1B[0m`), a2;
      };
    }
  }
  async exec(n) {
    let { result: t, error: o2 } = await n.request({ body: this.command });
    if (o2)
      throw new u(o2);
    if (typeof t > "u")
      throw new Error("Request did not return a result");
    return this.deserialize(t);
  }
};
var g = class extends e {
  constructor(n, t) {
    super(["append", ...n], t);
  }
};
var x = class extends e {
  constructor([n, t, o2], m) {
    let r = ["bitcount", n];
    typeof t == "number" && r.push(t), typeof o2 == "number" && r.push(o2), super(r, m);
  }
};
var f = class {
  constructor(n, t, o2, m = (r) => r.exec(this.client)) {
    __publicField(this, "command");
    this.client = t;
    this.opts = o2;
    this.execOperation = m;
    this.command = ["bitfield", ...n];
  }
  chain(...n) {
    return this.command.push(...n), this;
  }
  get(...n) {
    return this.chain("get", ...n);
  }
  set(...n) {
    return this.chain("set", ...n);
  }
  incrby(...n) {
    return this.chain("incrby", ...n);
  }
  overflow(n) {
    return this.chain("overflow", n);
  }
  exec() {
    let n = new e(this.command, this.opts);
    return this.execOperation(n);
  }
};
var y = class extends e {
  constructor(n, t) {
    super(["bitop", ...n], t);
  }
};
var b = class extends e {
  constructor(n, t) {
    super(["bitpos", ...n], t);
  }
};
var T = class extends e {
  constructor([n, t, o2], m) {
    super(["COPY", n, t, ...(o2 == null ? void 0 : o2.replace) ? ["REPLACE"] : []], { ...m, deserialize(r) {
      return r > 0 ? "COPIED" : "NOT_COPIED";
    } });
  }
};
var O = class extends e {
  constructor(n) {
    super(["dbsize"], n);
  }
};
var w = class extends e {
  constructor(n, t) {
    super(["decr", ...n], t);
  }
};
var D = class extends e {
  constructor(n, t) {
    super(["decrby", ...n], t);
  }
};
var A = class extends e {
  constructor(n, t) {
    super(["del", ...n], t);
  }
};
var k = class extends e {
  constructor(n, t) {
    super(["echo", ...n], t);
  }
};
var R = class extends e {
  constructor([n, t, o2], m) {
    super(["eval", n, t.length, ...t, ...o2 ?? []], m);
  }
};
var S = class extends e {
  constructor([n, t, o2], m) {
    super(["evalsha", n, t.length, ...t, ...o2 ?? []], m);
  }
};
var E = class extends e {
  constructor(n, t) {
    super(["exists", ...n], t);
  }
};
var M = class extends e {
  constructor(n, t) {
    super(["expire", ...n.filter(Boolean)], t);
  }
};
var v = class extends e {
  constructor(n, t) {
    super(["expireat", ...n], t);
  }
};
var P = class extends e {
  constructor(n, t) {
    let o2 = ["flushall"];
    n && n.length > 0 && n[0].async && o2.push("async"), super(o2, t);
  }
};
var I = class extends e {
  constructor([n], t) {
    let o2 = ["flushdb"];
    (n == null ? void 0 : n.async) && o2.push("async"), super(o2, t);
  }
};
var N = class extends e {
  constructor([n, t, ...o2], m) {
    let r = ["geoadd", n];
    "nx" in t && t.nx ? r.push("nx") : "xx" in t && t.xx && r.push("xx"), "ch" in t && t.ch && r.push("ch"), "latitude" in t && t.latitude && r.push(t.longitude, t.latitude, t.member), r.push(...o2.flatMap(({ latitude: a2, longitude: i, member: p }) => [i, a2, p])), super(r, m);
  }
};
var L = class extends e {
  constructor([n, t, o2, m = "M"], r) {
    super(["GEODIST", n, t, o2, m], r);
  }
};
var z = class extends e {
  constructor(n, t) {
    let [o2] = n, m = Array.isArray(n[1]) ? n[1] : n.slice(1);
    super(["GEOHASH", o2, ...m], t);
  }
};
var G = class extends e {
  constructor(n, t) {
    let [o2] = n, m = Array.isArray(n[1]) ? n[1] : n.slice(1);
    super(["GEOPOS", o2, ...m], { deserialize: (r) => Ke(r), ...t });
  }
};
function Ke(s) {
  let n = [];
  for (let t of s)
    !(t == null ? void 0 : t[0]) || !(t == null ? void 0 : t[1]) || n.push({ lng: parseFloat(t[0]), lat: parseFloat(t[1]) });
  return n;
}
var K = class extends e {
  constructor([n, t, o2, m, r], a2) {
    let i = ["GEOSEARCH", n];
    (t.type === "FROMMEMBER" || t.type === "frommember") && i.push(t.type, t.member), (t.type === "FROMLONLAT" || t.type === "fromlonlat") && i.push(t.type, t.coordinate.lon, t.coordinate.lat), (o2.type === "BYRADIUS" || o2.type === "byradius") && i.push(o2.type, o2.radius, o2.radiusType), (o2.type === "BYBOX" || o2.type === "bybox") && i.push(o2.type, o2.rect.width, o2.rect.height, o2.rectType), i.push(m), (r == null ? void 0 : r.count) && i.push("COUNT", r.count.limit, ...r.count.any ? ["ANY"] : []);
    let p = (d) => !(r == null ? void 0 : r.withCoord) && !(r == null ? void 0 : r.withDist) && !(r == null ? void 0 : r.withHash) ? d.map((c) => {
      try {
        return { member: JSON.parse(c) };
      } catch {
        return { member: c };
      }
    }) : d.map((c) => {
      let De = 1, C = {};
      try {
        C.member = JSON.parse(c[0]);
      } catch {
        C.member = c[0];
      }
      return r.withDist && (C.dist = parseFloat(c[De++])), r.withHash && (C.hash = c[De++].toString()), r.withCoord && (C.coord = { long: parseFloat(c[De][0]), lat: parseFloat(c[De][1]) }), C;
    });
    super([...i, ...(r == null ? void 0 : r.withCoord) ? ["WITHCOORD"] : [], ...(r == null ? void 0 : r.withDist) ? ["WITHDIST"] : [], ...(r == null ? void 0 : r.withHash) ? ["WITHHASH"] : []], { deserialize: p, ...a2 });
  }
};
var X = class extends e {
  constructor([n, t, o2, m, r, a2], i) {
    let p = ["GEOSEARCHSTORE", n, t];
    (o2.type === "FROMMEMBER" || o2.type === "frommember") && p.push(o2.type, o2.member), (o2.type === "FROMLONLAT" || o2.type === "fromlonlat") && p.push(o2.type, o2.coordinate.lon, o2.coordinate.lat), (m.type === "BYRADIUS" || m.type === "byradius") && p.push(m.type, m.radius, m.radiusType), (m.type === "BYBOX" || m.type === "bybox") && p.push(m.type, m.rect.width, m.rect.height, m.rectType), p.push(r), (a2 == null ? void 0 : a2.count) && p.push("COUNT", a2.count.limit, ...a2.count.any ? ["ANY"] : []), super([...p, ...(a2 == null ? void 0 : a2.storeDist) ? ["STOREDIST"] : []], i);
  }
};
var U = class extends e {
  constructor(n, t) {
    super(["get", ...n], t);
  }
};
var J = class extends e {
  constructor(n, t) {
    super(["getbit", ...n], t);
  }
};
var B = class extends e {
  constructor(n, t) {
    super(["getdel", ...n], t);
  }
};
var Z = class extends e {
  constructor(n, t) {
    super(["getrange", ...n], t);
  }
};
var H = class extends e {
  constructor(n, t) {
    super(["getset", ...n], t);
  }
};
var F = class extends e {
  constructor(n, t) {
    super(["hdel", ...n], t);
  }
};
var $ = class extends e {
  constructor(n, t) {
    super(["hexists", ...n], t);
  }
};
var q = class extends e {
  constructor(n, t) {
    super(["hget", ...n], t);
  }
};
function Xe(s) {
  if (s.length === 0)
    return null;
  let n = {};
  for (; s.length >= 2; ) {
    let t = s.shift(), o2 = s.shift();
    try {
      !Number.isNaN(Number(o2)) && !Number.isSafeInteger(Number(o2)) ? n[t] = o2 : n[t] = JSON.parse(o2);
    } catch {
      n[t] = o2;
    }
  }
  return n;
}
var j = class extends e {
  constructor(n, t) {
    super(["hgetall", ...n], { deserialize: (o2) => Xe(o2), ...t });
  }
};
var Y = class extends e {
  constructor(n, t) {
    super(["hincrby", ...n], t);
  }
};
var V = class extends e {
  constructor(n, t) {
    super(["hincrbyfloat", ...n], t);
  }
};
var _ = class extends e {
  constructor([n], t) {
    super(["hkeys", n], t);
  }
};
var W = class extends e {
  constructor(n, t) {
    super(["hlen", ...n], t);
  }
};
function Ue(s, n) {
  if (n.length === 0 || n.every((o2) => o2 === null))
    return null;
  let t = {};
  for (let o2 = 0; o2 < s.length; o2++)
    try {
      t[s[o2]] = JSON.parse(n[o2]);
    } catch {
      t[s[o2]] = n[o2];
    }
  return t;
}
var Q = class extends e {
  constructor([n, ...t], o2) {
    super(["hmget", n, ...t], { deserialize: (m) => Ue(t, m), ...o2 });
  }
};
var nn = class extends e {
  constructor([n, t], o2) {
    super(["hmset", n, ...Object.entries(t).flatMap(([m, r]) => [m, r])], o2);
  }
};
function Je(s) {
  if (s.length === 0)
    return null;
  let n = {};
  for (; s.length >= 2; ) {
    let t = s.shift(), o2 = s.shift();
    try {
      n[t] = JSON.parse(o2);
    } catch {
      n[t] = o2;
    }
  }
  return n;
}
var tn = class extends e {
  constructor(n, t) {
    let o2 = ["hrandfield", n[0]];
    typeof n[1] == "number" && o2.push(n[1]), n[2] && o2.push("WITHVALUES"), super(o2, { deserialize: n[2] ? (m) => Je(m) : t == null ? void 0 : t.deserialize, ...t });
  }
};
var en = class extends e {
  constructor([n, t, o2], m) {
    let r = ["hscan", n, t];
    (o2 == null ? void 0 : o2.match) && r.push("match", o2.match), typeof (o2 == null ? void 0 : o2.count) == "number" && r.push("count", o2.count), super(r, { deserialize: h, ...m });
  }
};
var on = class extends e {
  constructor([n, t], o2) {
    super(["hset", n, ...Object.entries(t).flatMap(([m, r]) => [m, r])], o2);
  }
};
var sn = class extends e {
  constructor(n, t) {
    super(["hsetnx", ...n], t);
  }
};
var mn = class extends e {
  constructor(n, t) {
    super(["hstrlen", ...n], t);
  }
};
var rn = class extends e {
  constructor(n, t) {
    super(["hvals", ...n], t);
  }
};
var an = class extends e {
  constructor(n, t) {
    super(["incr", ...n], t);
  }
};
var pn = class extends e {
  constructor(n, t) {
    super(["incrby", ...n], t);
  }
};
var dn = class extends e {
  constructor(n, t) {
    super(["incrbyfloat", ...n], t);
  }
};
var cn = class extends e {
  constructor(n, t) {
    super(["JSON.ARRAPPEND", ...n], t);
  }
};
var un = class extends e {
  constructor(n, t) {
    super(["JSON.ARRINDEX", ...n], t);
  }
};
var hn = class extends e {
  constructor(n, t) {
    super(["JSON.ARRINSERT", ...n], t);
  }
};
var ln = class extends e {
  constructor(n, t) {
    super(["JSON.ARRLEN", n[0], n[1] ?? "$"], t);
  }
};
var Cn = class extends e {
  constructor(n, t) {
    super(["JSON.ARRPOP", ...n], t);
  }
};
var gn = class extends e {
  constructor(n, t) {
    let o2 = n[1] ?? "$", m = n[2] ?? 0, r = n[3] ?? 0;
    super(["JSON.ARRTRIM", n[0], o2, m, r], t);
  }
};
var xn = class extends e {
  constructor(n, t) {
    super(["JSON.CLEAR", ...n], t);
  }
};
var fn = class extends e {
  constructor(n, t) {
    super(["JSON.DEL", ...n], t);
  }
};
var yn = class extends e {
  constructor(n, t) {
    super(["JSON.FORGET", ...n], t);
  }
};
var bn = class extends e {
  constructor(n, t) {
    let o2 = ["JSON.GET"];
    typeof n[1] == "string" ? o2.push(...n) : (o2.push(n[0]), n[1] && (n[1].indent && o2.push("INDENT", n[1].indent), n[1].newline && o2.push("NEWLINE", n[1].newline), n[1].space && o2.push("SPACE", n[1].space)), o2.push(...n.slice(2))), super(o2, t);
  }
};
var Tn = class extends e {
  constructor(n, t) {
    super(["JSON.MGET", ...n[0], n[1]], t);
  }
};
var On = class extends e {
  constructor(n, t) {
    super(["JSON.NUMINCRBY", ...n], t);
  }
};
var wn = class extends e {
  constructor(n, t) {
    super(["JSON.NUMMULTBY", ...n], t);
  }
};
var Dn = class extends e {
  constructor(n, t) {
    super(["JSON.OBJKEYS", ...n], t);
  }
};
var An = class extends e {
  constructor(n, t) {
    super(["JSON.OBJLEN", ...n], t);
  }
};
var kn = class extends e {
  constructor(n, t) {
    super(["JSON.RESP", ...n], t);
  }
};
var Rn = class extends e {
  constructor(n, t) {
    let o2 = ["JSON.SET", n[0], n[1], n[2]];
    n[3] && (n[3].nx ? o2.push("NX") : n[3].xx && o2.push("XX")), super(o2, t);
  }
};
var Sn = class extends e {
  constructor(n, t) {
    super(["JSON.STRAPPEND", ...n], t);
  }
};
var En = class extends e {
  constructor(n, t) {
    super(["JSON.STRLEN", ...n], t);
  }
};
var Mn = class extends e {
  constructor(n, t) {
    super(["JSON.TOGGLE", ...n], t);
  }
};
var vn = class extends e {
  constructor(n, t) {
    super(["JSON.TYPE", ...n], t);
  }
};
var Pn = class extends e {
  constructor(n, t) {
    super(["keys", ...n], t);
  }
};
var In = class extends e {
  constructor(n, t) {
    super(["lindex", ...n], t);
  }
};
var Nn = class extends e {
  constructor(n, t) {
    super(["linsert", ...n], t);
  }
};
var Ln = class extends e {
  constructor(n, t) {
    super(["llen", ...n], t);
  }
};
var zn = class extends e {
  constructor(n, t) {
    super(["lmove", ...n], t);
  }
};
var Gn = class extends e {
  constructor(n, t) {
    let [o2, m, r, a2] = n;
    super(["LMPOP", o2, ...m, r, ...a2 ? ["COUNT", a2] : []], t);
  }
};
var Kn = class extends e {
  constructor(n, t) {
    super(["lpop", ...n], t);
  }
};
var Xn = class extends e {
  constructor(n, t) {
    var _a, _b, _c;
    let o2 = ["lpos", n[0], n[1]];
    typeof ((_a = n[2]) == null ? void 0 : _a.rank) == "number" && o2.push("rank", n[2].rank), typeof ((_b = n[2]) == null ? void 0 : _b.count) == "number" && o2.push("count", n[2].count), typeof ((_c = n[2]) == null ? void 0 : _c.maxLen) == "number" && o2.push("maxLen", n[2].maxLen), super(o2, t);
  }
};
var Un = class extends e {
  constructor(n, t) {
    super(["lpush", ...n], t);
  }
};
var Jn = class extends e {
  constructor(n, t) {
    super(["lpushx", ...n], t);
  }
};
var Bn = class extends e {
  constructor(n, t) {
    super(["lrange", ...n], t);
  }
};
var Zn = class extends e {
  constructor(n, t) {
    super(["lrem", ...n], t);
  }
};
var Hn = class extends e {
  constructor(n, t) {
    super(["lset", ...n], t);
  }
};
var Fn = class extends e {
  constructor(n, t) {
    super(["ltrim", ...n], t);
  }
};
var $n = class extends e {
  constructor(n, t) {
    let o2 = Array.isArray(n[0]) ? n[0] : n;
    super(["mget", ...o2], t);
  }
};
var qn = class extends e {
  constructor([n], t) {
    super(["mset", ...Object.entries(n).flatMap(([o2, m]) => [o2, m])], t);
  }
};
var jn = class extends e {
  constructor([n], t) {
    super(["msetnx", ...Object.entries(n).flatMap((o2) => o2)], t);
  }
};
var Yn = class extends e {
  constructor(n, t) {
    super(["persist", ...n], t);
  }
};
var Vn = class extends e {
  constructor(n, t) {
    super(["pexpire", ...n], t);
  }
};
var _n = class extends e {
  constructor(n, t) {
    super(["pexpireat", ...n], t);
  }
};
var Wn = class extends e {
  constructor(n, t) {
    super(["pfadd", ...n], t);
  }
};
var Qn = class extends e {
  constructor(n, t) {
    super(["pfcount", ...n], t);
  }
};
var nt = class extends e {
  constructor(n, t) {
    super(["pfmerge", ...n], t);
  }
};
var tt = class extends e {
  constructor(n, t) {
    let o2 = ["ping"];
    typeof n < "u" && typeof n[0] < "u" && o2.push(n[0]), super(o2, t);
  }
};
var et = class extends e {
  constructor(n, t) {
    super(["psetex", ...n], t);
  }
};
var ot = class extends e {
  constructor(n, t) {
    super(["pttl", ...n], t);
  }
};
var st = class extends e {
  constructor(n, t) {
    super(["publish", ...n], t);
  }
};
var mt = class extends e {
  constructor(n) {
    super(["randomkey"], n);
  }
};
var rt = class extends e {
  constructor(n, t) {
    super(["rename", ...n], t);
  }
};
var at = class extends e {
  constructor(n, t) {
    super(["renamenx", ...n], t);
  }
};
var it = class extends e {
  constructor(n, t) {
    super(["rpop", ...n], t);
  }
};
var pt = class extends e {
  constructor(n, t) {
    super(["rpush", ...n], t);
  }
};
var dt = class extends e {
  constructor(n, t) {
    super(["rpushx", ...n], t);
  }
};
var ct = class extends e {
  constructor(n, t) {
    super(["sadd", ...n], t);
  }
};
var ut = class extends e {
  constructor([n, t], o2) {
    let m = ["scan", n];
    (t == null ? void 0 : t.match) && m.push("match", t.match), typeof (t == null ? void 0 : t.count) == "number" && m.push("count", t.count), (t == null ? void 0 : t.type) && t.type.length > 0 && m.push("type", t.type), super(m, { deserialize: h, ...o2 });
  }
};
var ht = class extends e {
  constructor(n, t) {
    super(["scard", ...n], t);
  }
};
var lt = class extends e {
  constructor(n, t) {
    super(["script", "exists", ...n], { deserialize: (o2) => o2, ...t });
  }
};
var Ct = class extends e {
  constructor([n], t) {
    let o2 = ["script", "flush"];
    (n == null ? void 0 : n.sync) ? o2.push("sync") : (n == null ? void 0 : n.async) && o2.push("async"), super(o2, t);
  }
};
var gt = class extends e {
  constructor(n, t) {
    super(["script", "load", ...n], t);
  }
};
var xt = class extends e {
  constructor(n, t) {
    super(["sdiff", ...n], t);
  }
};
var ft = class extends e {
  constructor(n, t) {
    super(["sdiffstore", ...n], t);
  }
};
var yt = class extends e {
  constructor([n, t, o2], m) {
    let r = ["set", n, t];
    o2 && ("nx" in o2 && o2.nx ? r.push("nx") : "xx" in o2 && o2.xx && r.push("xx"), "get" in o2 && o2.get && r.push("get"), "ex" in o2 && typeof o2.ex == "number" ? r.push("ex", o2.ex) : "px" in o2 && typeof o2.px == "number" ? r.push("px", o2.px) : "exat" in o2 && typeof o2.exat == "number" ? r.push("exat", o2.exat) : "pxat" in o2 && typeof o2.pxat == "number" ? r.push("pxat", o2.pxat) : "keepTtl" in o2 && o2.keepTtl && r.push("keepTtl")), super(r, m);
  }
};
var bt = class extends e {
  constructor(n, t) {
    super(["setbit", ...n], t);
  }
};
var Tt = class extends e {
  constructor(n, t) {
    super(["setex", ...n], t);
  }
};
var Ot = class extends e {
  constructor(n, t) {
    super(["setnx", ...n], t);
  }
};
var wt = class extends e {
  constructor(n, t) {
    super(["setrange", ...n], t);
  }
};
var Dt = class extends e {
  constructor(n, t) {
    super(["sinter", ...n], t);
  }
};
var At = class extends e {
  constructor(n, t) {
    super(["sinterstore", ...n], t);
  }
};
var kt = class extends e {
  constructor(n, t) {
    super(["sismember", ...n], t);
  }
};
var Rt = class extends e {
  constructor(n, t) {
    super(["smembers", ...n], t);
  }
};
var St = class extends e {
  constructor(n, t) {
    super(["smismember", n[0], ...n[1]], t);
  }
};
var Et = class extends e {
  constructor(n, t) {
    super(["smove", ...n], t);
  }
};
var Mt = class extends e {
  constructor([n, t], o2) {
    let m = ["spop", n];
    typeof t == "number" && m.push(t), super(m, o2);
  }
};
var vt = class extends e {
  constructor([n, t], o2) {
    let m = ["srandmember", n];
    typeof t == "number" && m.push(t), super(m, o2);
  }
};
var Pt = class extends e {
  constructor(n, t) {
    super(["srem", ...n], t);
  }
};
var It = class extends e {
  constructor([n, t, o2], m) {
    let r = ["sscan", n, t];
    (o2 == null ? void 0 : o2.match) && r.push("match", o2.match), typeof (o2 == null ? void 0 : o2.count) == "number" && r.push("count", o2.count), super(r, { deserialize: h, ...m });
  }
};
var Nt = class extends e {
  constructor(n, t) {
    super(["strlen", ...n], t);
  }
};
var Lt = class extends e {
  constructor(n, t) {
    super(["sunion", ...n], t);
  }
};
var zt = class extends e {
  constructor(n, t) {
    super(["sunionstore", ...n], t);
  }
};
var Gt = class extends e {
  constructor(n) {
    super(["time"], n);
  }
};
var Kt = class extends e {
  constructor(n, t) {
    super(["touch", ...n], t);
  }
};
var Xt = class extends e {
  constructor(n, t) {
    super(["ttl", ...n], t);
  }
};
var Ut = class extends e {
  constructor(n, t) {
    super(["type", ...n], t);
  }
};
var Jt = class extends e {
  constructor(n, t) {
    super(["unlink", ...n], t);
  }
};
var Bt = class extends e {
  constructor([n, t, o2], m) {
    let r = Array.isArray(o2) ? [...o2] : [o2];
    super(["XACK", n, t, ...r], m);
  }
};
var Zt = class extends e {
  constructor([n, t, o2, m], r) {
    let a2 = ["XADD", n];
    m && (m.nomkStream && a2.push("NOMKSTREAM"), m.trim && (a2.push(m.trim.type, m.trim.comparison, m.trim.threshold), typeof m.trim.limit < "u" && a2.push("LIMIT", m.trim.limit))), a2.push(t);
    for (let [i, p] of Object.entries(o2))
      a2.push(i, p);
    super(a2, r);
  }
};
var Ht = class extends e {
  constructor([n, t, o2, m, r, a2], i) {
    let p = [];
    (a2 == null ? void 0 : a2.count) && p.push("COUNT", a2.count), (a2 == null ? void 0 : a2.justId) && p.push("JUSTID"), super(["XAUTOCLAIM", n, t, o2, m, r, ...p], i);
  }
};
var Ft = class extends e {
  constructor([n, t, o2, m, r, a2], i) {
    let p = Array.isArray(r) ? [...r] : [r], d = [];
    (a2 == null ? void 0 : a2.idleMS) && d.push("IDLE", a2.idleMS), (a2 == null ? void 0 : a2.idleMS) && d.push("TIME", a2.timeMS), (a2 == null ? void 0 : a2.retryCount) && d.push("RETRYCOUNT", a2 == null ? void 0 : a2.retryCount), (a2 == null ? void 0 : a2.force) && d.push("FORCE"), (a2 == null ? void 0 : a2.justId) && d.push("JUSTID"), (a2 == null ? void 0 : a2.lastId) && d.push("LASTID", a2.lastId), super(["XCLAIM", n, t, o2, m, ...p, ...d], i);
  }
};
var $t = class extends e {
  constructor([n, t], o2) {
    let m = Array.isArray(t) ? [...t] : [t];
    super(["XDEL", n, ...m], o2);
  }
};
var qt = class extends e {
  constructor([n, t], o2) {
    let m = ["XGROUP"];
    switch (t.type) {
      case "CREATE":
        m.push("CREATE", n, t.group, t.id), t.options && (t.options.MKSTREAM && m.push("MKSTREAM"), t.options.ENTRIESREAD !== void 0 && m.push("ENTRIESREAD", t.options.ENTRIESREAD.toString()));
        break;
      case "CREATECONSUMER":
        m.push("CREATECONSUMER", n, t.group, t.consumer);
        break;
      case "DELCONSUMER":
        m.push("DELCONSUMER", n, t.group, t.consumer);
        break;
      case "DESTROY":
        m.push("DESTROY", n, t.group);
        break;
      case "SETID":
        m.push("SETID", n, t.group, t.id), t.options && t.options.ENTRIESREAD !== void 0 && m.push("ENTRIESREAD", t.options.ENTRIESREAD.toString());
        break;
      default:
        throw new Error("Invalid XGROUP");
    }
    super(m, o2);
  }
};
var jt = class extends e {
  constructor([n, t], o2) {
    let m = [];
    t.type === "CONSUMERS" ? m.push("CONSUMERS", n, t.group) : m.push("GROUPS", n), super(["XINFO", ...m], o2);
  }
};
var Yt = class extends e {
  constructor(n, t) {
    super(["XLEN", ...n], t);
  }
};
var Vt = class extends e {
  constructor([n, t, o2, m, r, a2], i) {
    let p = typeof (a2 == null ? void 0 : a2.consumer) < "u" ? Array.isArray(a2.consumer) ? [...a2.consumer] : [a2.consumer] : [];
    super(["XPENDING", n, t, ...(a2 == null ? void 0 : a2.idleTime) ? ["IDLE", a2.idleTime] : [], o2, m, r, ...p], i);
  }
};
function Be(s) {
  let n = {};
  for (let t of s)
    for (; t.length >= 2; ) {
      let o2 = t.shift(), m = t.shift();
      for ((o2 in n) || (n[o2] = {}); m.length >= 2; ) {
        let r = m.shift(), a2 = m.shift();
        try {
          n[o2][r] = JSON.parse(a2);
        } catch {
          n[o2][r] = a2;
        }
      }
    }
  return n;
}
var _t = class extends e {
  constructor([n, t, o2, m], r) {
    let a2 = ["XRANGE", n, t, o2];
    typeof m == "number" && a2.push("COUNT", m), super(a2, { deserialize: (i) => Be(i), ...r });
  }
};
var Ze = "ERR Unbalanced XREAD list of streams: for each stream key an ID or '$' must be specified";
var Wt = class extends e {
  constructor([n, t, o2], m) {
    if (Array.isArray(n) && Array.isArray(t) && n.length !== t.length)
      throw new Error(Ze);
    let r = [];
    typeof (o2 == null ? void 0 : o2.count) == "number" && r.push("COUNT", o2.count), typeof (o2 == null ? void 0 : o2.blockMS) == "number" && r.push("BLOCK", o2.blockMS), r.push("STREAMS", ...Array.isArray(n) ? [...n] : [n], ...Array.isArray(t) ? [...t] : [t]), super(["XREAD", ...r], m);
  }
};
var He = "ERR Unbalanced XREADGROUP list of streams: for each stream key an ID or '$' must be specified";
var Qt = class extends e {
  constructor([n, t, o2, m, r], a2) {
    if (Array.isArray(o2) && Array.isArray(m) && o2.length !== m.length)
      throw new Error(He);
    let i = [];
    typeof (r == null ? void 0 : r.count) == "number" && i.push("COUNT", r.count), typeof (r == null ? void 0 : r.blockMS) == "number" && i.push("BLOCK", r.blockMS), typeof (r == null ? void 0 : r.NOACK) == "boolean" && (r == null ? void 0 : r.NOACK) && i.push("NOACK"), i.push("STREAMS", ...Array.isArray(o2) ? [...o2] : [o2], ...Array.isArray(m) ? [...m] : [m]), super(["XREADGROUP", "GROUP", n, t, ...i], a2);
  }
};
var ne = class extends e {
  constructor([n, t, o2, m], r) {
    let a2 = ["XREVRANGE", n, t, o2];
    typeof m == "number" && a2.push("COUNT", m), super(a2, { deserialize: (i) => Fe(i), ...r });
  }
};
function Fe(s) {
  let n = {};
  for (let t of s)
    for (; t.length >= 2; ) {
      let o2 = t.shift(), m = t.shift();
      for ((o2 in n) || (n[o2] = {}); m.length >= 2; ) {
        let r = m.shift(), a2 = m.shift();
        try {
          n[o2][r] = JSON.parse(a2);
        } catch {
          n[o2][r] = a2;
        }
      }
    }
  return n;
}
var te = class extends e {
  constructor([n, t], o2) {
    let { limit: m, strategy: r, threshold: a2, exactness: i = "~" } = t;
    super(["XTRIM", n, r, i, a2, ...m ? ["LIMIT", m] : []], o2);
  }
};
var l = class extends e {
  constructor([n, t, ...o2], m) {
    let r = ["zadd", n];
    "nx" in t && t.nx ? r.push("nx") : "xx" in t && t.xx && r.push("xx"), "ch" in t && t.ch && r.push("ch"), "incr" in t && t.incr && r.push("incr"), "lt" in t && t.lt ? r.push("lt") : "gt" in t && t.gt && r.push("gt"), "score" in t && "member" in t && r.push(t.score, t.member), r.push(...o2.flatMap(({ score: a2, member: i }) => [a2, i])), super(r, m);
  }
};
var ee = class extends e {
  constructor(n, t) {
    super(["zcard", ...n], t);
  }
};
var oe = class extends e {
  constructor(n, t) {
    super(["zcount", ...n], t);
  }
};
var se = class extends e {
  constructor(n, t) {
    super(["zincrby", ...n], t);
  }
};
var me = class extends e {
  constructor([n, t, o2, m], r) {
    let a2 = ["zinterstore", n, t];
    Array.isArray(o2) ? a2.push(...o2) : a2.push(o2), m && ("weights" in m && m.weights ? a2.push("weights", ...m.weights) : "weight" in m && typeof m.weight == "number" && a2.push("weights", m.weight), "aggregate" in m && a2.push("aggregate", m.aggregate)), super(a2, r);
  }
};
var re = class extends e {
  constructor(n, t) {
    super(["zlexcount", ...n], t);
  }
};
var ae = class extends e {
  constructor([n, t], o2) {
    let m = ["zpopmax", n];
    typeof t == "number" && m.push(t), super(m, o2);
  }
};
var ie = class extends e {
  constructor([n, t], o2) {
    let m = ["zpopmin", n];
    typeof t == "number" && m.push(t), super(m, o2);
  }
};
var pe = class extends e {
  constructor([n, t, o2, m], r) {
    let a2 = ["zrange", n, t, o2];
    (m == null ? void 0 : m.byScore) && a2.push("byscore"), (m == null ? void 0 : m.byLex) && a2.push("bylex"), (m == null ? void 0 : m.rev) && a2.push("rev"), typeof (m == null ? void 0 : m.count) < "u" && typeof (m == null ? void 0 : m.offset) < "u" && a2.push("limit", m.offset, m.count), (m == null ? void 0 : m.withScores) && a2.push("withscores"), super(a2, r);
  }
};
var de = class extends e {
  constructor(n, t) {
    super(["zrank", ...n], t);
  }
};
var ce = class extends e {
  constructor(n, t) {
    super(["zrem", ...n], t);
  }
};
var ue = class extends e {
  constructor(n, t) {
    super(["zremrangebylex", ...n], t);
  }
};
var he = class extends e {
  constructor(n, t) {
    super(["zremrangebyrank", ...n], t);
  }
};
var le = class extends e {
  constructor(n, t) {
    super(["zremrangebyscore", ...n], t);
  }
};
var Ce = class extends e {
  constructor(n, t) {
    super(["zrevrank", ...n], t);
  }
};
var ge = class extends e {
  constructor([n, t, o2], m) {
    let r = ["zscan", n, t];
    (o2 == null ? void 0 : o2.match) && r.push("match", o2.match), typeof (o2 == null ? void 0 : o2.count) == "number" && r.push("count", o2.count), super(r, { deserialize: h, ...m });
  }
};
var xe = class extends e {
  constructor(n, t) {
    super(["zscore", ...n], t);
  }
};
var fe = class extends e {
  constructor([n, t, o2], m) {
    let r = ["zunion", n];
    Array.isArray(t) ? r.push(...t) : r.push(t), o2 && ("weights" in o2 && o2.weights ? r.push("weights", ...o2.weights) : "weight" in o2 && typeof o2.weight == "number" && r.push("weights", o2.weight), "aggregate" in o2 && r.push("aggregate", o2.aggregate), (o2 == null ? void 0 : o2.withScores) && r.push("withscores")), super(r, m);
  }
};
var ye = class extends e {
  constructor([n, t, o2, m], r) {
    let a2 = ["zunionstore", n, t];
    Array.isArray(o2) ? a2.push(...o2) : a2.push(o2), m && ("weights" in m && m.weights ? a2.push("weights", ...m.weights) : "weight" in m && typeof m.weight == "number" && a2.push("weights", m.weight), "aggregate" in m && a2.push("aggregate", m.aggregate)), super(a2, r);
  }
};
var be = class extends e {
  constructor(n, t) {
    super(["zdiffstore", ...n], t);
  }
};
var Te = class extends e {
  constructor(n, t) {
    let [o2, m] = n;
    super(["zmscore", o2, ...m], t);
  }
};
var we = class {
  constructor(n) {
    __publicField(this, "client");
    __publicField(this, "commands");
    __publicField(this, "commandOptions");
    __publicField(this, "multiExec");
    __publicField(this, "exec", async () => {
      if (this.commands.length === 0)
        throw new Error("Pipeline is empty");
      let n = this.multiExec ? ["multi-exec"] : ["pipeline"];
      return (await this.client.request({ path: n, body: Object.values(this.commands).map((o2) => o2.command) })).map(({ error: o2, result: m }, r) => {
        if (o2)
          throw new u(`Command ${r + 1} [ ${this.commands[r].command[0]} ] failed: ${o2}`);
        return this.commands[r].deserialize(m);
      });
    });
    __publicField(this, "append", (...n) => this.chain(new g(n, this.commandOptions)));
    __publicField(this, "bitcount", (...n) => this.chain(new x(n, this.commandOptions)));
    __publicField(this, "bitfield", (...n) => new f(n, this.client, this.commandOptions, this.chain.bind(this)));
    __publicField(this, "bitop", (n, t, o2, ...m) => this.chain(new y([n, t, o2, ...m], this.commandOptions)));
    __publicField(this, "bitpos", (...n) => this.chain(new b(n, this.commandOptions)));
    __publicField(this, "copy", (...n) => this.chain(new T(n, this.commandOptions)));
    __publicField(this, "zdiffstore", (...n) => this.chain(new be(n, this.commandOptions)));
    __publicField(this, "dbsize", () => this.chain(new O(this.commandOptions)));
    __publicField(this, "decr", (...n) => this.chain(new w(n, this.commandOptions)));
    __publicField(this, "decrby", (...n) => this.chain(new D(n, this.commandOptions)));
    __publicField(this, "del", (...n) => this.chain(new A(n, this.commandOptions)));
    __publicField(this, "echo", (...n) => this.chain(new k(n, this.commandOptions)));
    __publicField(this, "eval", (...n) => this.chain(new R(n, this.commandOptions)));
    __publicField(this, "evalsha", (...n) => this.chain(new S(n, this.commandOptions)));
    __publicField(this, "exists", (...n) => this.chain(new E(n, this.commandOptions)));
    __publicField(this, "expire", (...n) => this.chain(new M(n, this.commandOptions)));
    __publicField(this, "expireat", (...n) => this.chain(new v(n, this.commandOptions)));
    __publicField(this, "flushall", (n) => this.chain(new P(n, this.commandOptions)));
    __publicField(this, "flushdb", (...n) => this.chain(new I(n, this.commandOptions)));
    __publicField(this, "geoadd", (...n) => this.chain(new N(n, this.commandOptions)));
    __publicField(this, "geodist", (...n) => this.chain(new L(n, this.commandOptions)));
    __publicField(this, "geopos", (...n) => this.chain(new G(n, this.commandOptions)));
    __publicField(this, "geohash", (...n) => this.chain(new z(n, this.commandOptions)));
    __publicField(this, "geosearch", (...n) => this.chain(new K(n, this.commandOptions)));
    __publicField(this, "geosearchstore", (...n) => this.chain(new X(n, this.commandOptions)));
    __publicField(this, "get", (...n) => this.chain(new U(n, this.commandOptions)));
    __publicField(this, "getbit", (...n) => this.chain(new J(n, this.commandOptions)));
    __publicField(this, "getdel", (...n) => this.chain(new B(n, this.commandOptions)));
    __publicField(this, "getrange", (...n) => this.chain(new Z(n, this.commandOptions)));
    __publicField(this, "getset", (n, t) => this.chain(new H([n, t], this.commandOptions)));
    __publicField(this, "hdel", (...n) => this.chain(new F(n, this.commandOptions)));
    __publicField(this, "hexists", (...n) => this.chain(new $(n, this.commandOptions)));
    __publicField(this, "hget", (...n) => this.chain(new q(n, this.commandOptions)));
    __publicField(this, "hgetall", (...n) => this.chain(new j(n, this.commandOptions)));
    __publicField(this, "hincrby", (...n) => this.chain(new Y(n, this.commandOptions)));
    __publicField(this, "hincrbyfloat", (...n) => this.chain(new V(n, this.commandOptions)));
    __publicField(this, "hkeys", (...n) => this.chain(new _(n, this.commandOptions)));
    __publicField(this, "hlen", (...n) => this.chain(new W(n, this.commandOptions)));
    __publicField(this, "hmget", (...n) => this.chain(new Q(n, this.commandOptions)));
    __publicField(this, "hmset", (n, t) => this.chain(new nn([n, t], this.commandOptions)));
    __publicField(this, "hrandfield", (n, t, o2) => this.chain(new tn([n, t, o2], this.commandOptions)));
    __publicField(this, "hscan", (...n) => this.chain(new en(n, this.commandOptions)));
    __publicField(this, "hset", (n, t) => this.chain(new on([n, t], this.commandOptions)));
    __publicField(this, "hsetnx", (n, t, o2) => this.chain(new sn([n, t, o2], this.commandOptions)));
    __publicField(this, "hstrlen", (...n) => this.chain(new mn(n, this.commandOptions)));
    __publicField(this, "hvals", (...n) => this.chain(new rn(n, this.commandOptions)));
    __publicField(this, "incr", (...n) => this.chain(new an(n, this.commandOptions)));
    __publicField(this, "incrby", (...n) => this.chain(new pn(n, this.commandOptions)));
    __publicField(this, "incrbyfloat", (...n) => this.chain(new dn(n, this.commandOptions)));
    __publicField(this, "keys", (...n) => this.chain(new Pn(n, this.commandOptions)));
    __publicField(this, "lindex", (...n) => this.chain(new In(n, this.commandOptions)));
    __publicField(this, "linsert", (n, t, o2, m) => this.chain(new Nn([n, t, o2, m], this.commandOptions)));
    __publicField(this, "llen", (...n) => this.chain(new Ln(n, this.commandOptions)));
    __publicField(this, "lmove", (...n) => this.chain(new zn(n, this.commandOptions)));
    __publicField(this, "lpop", (...n) => this.chain(new Kn(n, this.commandOptions)));
    __publicField(this, "lmpop", (...n) => this.chain(new Gn(n, this.commandOptions)));
    __publicField(this, "lpos", (...n) => this.chain(new Xn(n, this.commandOptions)));
    __publicField(this, "lpush", (n, ...t) => this.chain(new Un([n, ...t], this.commandOptions)));
    __publicField(this, "lpushx", (n, ...t) => this.chain(new Jn([n, ...t], this.commandOptions)));
    __publicField(this, "lrange", (...n) => this.chain(new Bn(n, this.commandOptions)));
    __publicField(this, "lrem", (n, t, o2) => this.chain(new Zn([n, t, o2], this.commandOptions)));
    __publicField(this, "lset", (n, t, o2) => this.chain(new Hn([n, t, o2], this.commandOptions)));
    __publicField(this, "ltrim", (...n) => this.chain(new Fn(n, this.commandOptions)));
    __publicField(this, "mget", (...n) => this.chain(new $n(n, this.commandOptions)));
    __publicField(this, "mset", (n) => this.chain(new qn([n], this.commandOptions)));
    __publicField(this, "msetnx", (n) => this.chain(new jn([n], this.commandOptions)));
    __publicField(this, "persist", (...n) => this.chain(new Yn(n, this.commandOptions)));
    __publicField(this, "pexpire", (...n) => this.chain(new Vn(n, this.commandOptions)));
    __publicField(this, "pexpireat", (...n) => this.chain(new _n(n, this.commandOptions)));
    __publicField(this, "pfadd", (...n) => this.chain(new Wn(n, this.commandOptions)));
    __publicField(this, "pfcount", (...n) => this.chain(new Qn(n, this.commandOptions)));
    __publicField(this, "pfmerge", (...n) => this.chain(new nt(n, this.commandOptions)));
    __publicField(this, "ping", (n) => this.chain(new tt(n, this.commandOptions)));
    __publicField(this, "psetex", (n, t, o2) => this.chain(new et([n, t, o2], this.commandOptions)));
    __publicField(this, "pttl", (...n) => this.chain(new ot(n, this.commandOptions)));
    __publicField(this, "publish", (...n) => this.chain(new st(n, this.commandOptions)));
    __publicField(this, "randomkey", () => this.chain(new mt(this.commandOptions)));
    __publicField(this, "rename", (...n) => this.chain(new rt(n, this.commandOptions)));
    __publicField(this, "renamenx", (...n) => this.chain(new at(n, this.commandOptions)));
    __publicField(this, "rpop", (...n) => this.chain(new it(n, this.commandOptions)));
    __publicField(this, "rpush", (n, ...t) => this.chain(new pt([n, ...t], this.commandOptions)));
    __publicField(this, "rpushx", (n, ...t) => this.chain(new dt([n, ...t], this.commandOptions)));
    __publicField(this, "sadd", (n, ...t) => this.chain(new ct([n, ...t], this.commandOptions)));
    __publicField(this, "scan", (...n) => this.chain(new ut(n, this.commandOptions)));
    __publicField(this, "scard", (...n) => this.chain(new ht(n, this.commandOptions)));
    __publicField(this, "scriptExists", (...n) => this.chain(new lt(n, this.commandOptions)));
    __publicField(this, "scriptFlush", (...n) => this.chain(new Ct(n, this.commandOptions)));
    __publicField(this, "scriptLoad", (...n) => this.chain(new gt(n, this.commandOptions)));
    __publicField(this, "sdiff", (...n) => this.chain(new xt(n, this.commandOptions)));
    __publicField(this, "sdiffstore", (...n) => this.chain(new ft(n, this.commandOptions)));
    __publicField(this, "set", (n, t, o2) => this.chain(new yt([n, t, o2], this.commandOptions)));
    __publicField(this, "setbit", (...n) => this.chain(new bt(n, this.commandOptions)));
    __publicField(this, "setex", (n, t, o2) => this.chain(new Tt([n, t, o2], this.commandOptions)));
    __publicField(this, "setnx", (n, t) => this.chain(new Ot([n, t], this.commandOptions)));
    __publicField(this, "setrange", (...n) => this.chain(new wt(n, this.commandOptions)));
    __publicField(this, "sinter", (...n) => this.chain(new Dt(n, this.commandOptions)));
    __publicField(this, "sinterstore", (...n) => this.chain(new At(n, this.commandOptions)));
    __publicField(this, "sismember", (n, t) => this.chain(new kt([n, t], this.commandOptions)));
    __publicField(this, "smembers", (...n) => this.chain(new Rt(n, this.commandOptions)));
    __publicField(this, "smismember", (n, t) => this.chain(new St([n, t], this.commandOptions)));
    __publicField(this, "smove", (n, t, o2) => this.chain(new Et([n, t, o2], this.commandOptions)));
    __publicField(this, "spop", (...n) => this.chain(new Mt(n, this.commandOptions)));
    __publicField(this, "srandmember", (...n) => this.chain(new vt(n, this.commandOptions)));
    __publicField(this, "srem", (n, ...t) => this.chain(new Pt([n, ...t], this.commandOptions)));
    __publicField(this, "sscan", (...n) => this.chain(new It(n, this.commandOptions)));
    __publicField(this, "strlen", (...n) => this.chain(new Nt(n, this.commandOptions)));
    __publicField(this, "sunion", (...n) => this.chain(new Lt(n, this.commandOptions)));
    __publicField(this, "sunionstore", (...n) => this.chain(new zt(n, this.commandOptions)));
    __publicField(this, "time", () => this.chain(new Gt(this.commandOptions)));
    __publicField(this, "touch", (...n) => this.chain(new Kt(n, this.commandOptions)));
    __publicField(this, "ttl", (...n) => this.chain(new Xt(n, this.commandOptions)));
    __publicField(this, "type", (...n) => this.chain(new Ut(n, this.commandOptions)));
    __publicField(this, "unlink", (...n) => this.chain(new Jt(n, this.commandOptions)));
    __publicField(this, "zadd", (...n) => "score" in n[1] ? this.chain(new l([n[0], n[1], ...n.slice(2)], this.commandOptions)) : this.chain(new l([n[0], n[1], ...n.slice(2)], this.commandOptions)));
    __publicField(this, "xadd", (...n) => this.chain(new Zt(n, this.commandOptions)));
    __publicField(this, "xack", (...n) => this.chain(new Bt(n, this.commandOptions)));
    __publicField(this, "xdel", (...n) => this.chain(new $t(n, this.commandOptions)));
    __publicField(this, "xgroup", (...n) => this.chain(new qt(n, this.commandOptions)));
    __publicField(this, "xread", (...n) => this.chain(new Wt(n, this.commandOptions)));
    __publicField(this, "xreadgroup", (...n) => this.chain(new Qt(n, this.commandOptions)));
    __publicField(this, "xinfo", (...n) => this.chain(new jt(n, this.commandOptions)));
    __publicField(this, "xlen", (...n) => this.chain(new Yt(n, this.commandOptions)));
    __publicField(this, "xpending", (...n) => this.chain(new Vt(n, this.commandOptions)));
    __publicField(this, "xclaim", (...n) => this.chain(new Ft(n, this.commandOptions)));
    __publicField(this, "xautoclaim", (...n) => this.chain(new Ht(n, this.commandOptions)));
    __publicField(this, "xtrim", (...n) => this.chain(new te(n, this.commandOptions)));
    __publicField(this, "xrange", (...n) => this.chain(new _t(n, this.commandOptions)));
    __publicField(this, "xrevrange", (...n) => this.chain(new ne(n, this.commandOptions)));
    __publicField(this, "zcard", (...n) => this.chain(new ee(n, this.commandOptions)));
    __publicField(this, "zcount", (...n) => this.chain(new oe(n, this.commandOptions)));
    __publicField(this, "zincrby", (n, t, o2) => this.chain(new se([n, t, o2], this.commandOptions)));
    __publicField(this, "zinterstore", (...n) => this.chain(new me(n, this.commandOptions)));
    __publicField(this, "zlexcount", (...n) => this.chain(new re(n, this.commandOptions)));
    __publicField(this, "zmscore", (...n) => this.chain(new Te(n, this.commandOptions)));
    __publicField(this, "zpopmax", (...n) => this.chain(new ae(n, this.commandOptions)));
    __publicField(this, "zpopmin", (...n) => this.chain(new ie(n, this.commandOptions)));
    __publicField(this, "zrange", (...n) => this.chain(new pe(n, this.commandOptions)));
    __publicField(this, "zrank", (n, t) => this.chain(new de([n, t], this.commandOptions)));
    __publicField(this, "zrem", (n, ...t) => this.chain(new ce([n, ...t], this.commandOptions)));
    __publicField(this, "zremrangebylex", (...n) => this.chain(new ue(n, this.commandOptions)));
    __publicField(this, "zremrangebyrank", (...n) => this.chain(new he(n, this.commandOptions)));
    __publicField(this, "zremrangebyscore", (...n) => this.chain(new le(n, this.commandOptions)));
    __publicField(this, "zrevrank", (n, t) => this.chain(new Ce([n, t], this.commandOptions)));
    __publicField(this, "zscan", (...n) => this.chain(new ge(n, this.commandOptions)));
    __publicField(this, "zscore", (n, t) => this.chain(new xe([n, t], this.commandOptions)));
    __publicField(this, "zunionstore", (...n) => this.chain(new ye(n, this.commandOptions)));
    __publicField(this, "zunion", (...n) => this.chain(new fe(n, this.commandOptions)));
    var _a;
    if (this.client = n.client, this.commands = [], this.commandOptions = n.commandOptions, this.multiExec = n.multiExec ?? false, (_a = this.commandOptions) == null ? void 0 : _a.latencyLogging) {
      let t = this.exec.bind(this);
      this.exec = async () => {
        let o2 = performance.now(), m = await t(), a2 = (performance.now() - o2).toFixed(2);
        return console.log(`Latency for \x1B[38;2;19;185;39m${this.multiExec ? ["MULTI-EXEC"] : ["PIPELINE"].toString().toUpperCase()}\x1B[0m: \x1B[38;2;0;255;255m${a2} ms\x1B[0m`), m;
      };
    }
  }
  length() {
    return this.commands.length;
  }
  chain(n) {
    return this.commands.push(n), this;
  }
  get json() {
    return { arrappend: (...n) => this.chain(new cn(n, this.commandOptions)), arrindex: (...n) => this.chain(new un(n, this.commandOptions)), arrinsert: (...n) => this.chain(new hn(n, this.commandOptions)), arrlen: (...n) => this.chain(new ln(n, this.commandOptions)), arrpop: (...n) => this.chain(new Cn(n, this.commandOptions)), arrtrim: (...n) => this.chain(new gn(n, this.commandOptions)), clear: (...n) => this.chain(new xn(n, this.commandOptions)), del: (...n) => this.chain(new fn(n, this.commandOptions)), forget: (...n) => this.chain(new yn(n, this.commandOptions)), get: (...n) => this.chain(new bn(n, this.commandOptions)), mget: (...n) => this.chain(new Tn(n, this.commandOptions)), numincrby: (...n) => this.chain(new On(n, this.commandOptions)), nummultby: (...n) => this.chain(new wn(n, this.commandOptions)), objkeys: (...n) => this.chain(new Dn(n, this.commandOptions)), objlen: (...n) => this.chain(new An(n, this.commandOptions)), resp: (...n) => this.chain(new kn(n, this.commandOptions)), set: (...n) => this.chain(new Rn(n, this.commandOptions)), strappend: (...n) => this.chain(new Sn(n, this.commandOptions)), strlen: (...n) => this.chain(new En(n, this.commandOptions)), toggle: (...n) => this.chain(new Mn(n, this.commandOptions)), type: (...n) => this.chain(new vn(n, this.commandOptions)) };
  }
};
var Ae = class {
  constructor(n, t) {
    __publicField(this, "script");
    __publicField(this, "sha1");
    __publicField(this, "redis");
    this.redis = n, this.sha1 = this.digest(t), this.script = t;
  }
  async eval(n, t) {
    return await this.redis.eval(this.script, n, t);
  }
  async evalsha(n, t) {
    return await this.redis.evalsha(this.sha1, n, t);
  }
  async exec(n, t) {
    return await this.redis.evalsha(this.sha1, n, t).catch(async (m) => {
      if (m instanceof Error && m.message.toLowerCase().includes("noscript"))
        return await this.redis.eval(this.script, n, t);
      throw m;
    });
  }
  digest(n) {
    return import_enc_hex.default.stringify((0, import_sha1.default)(n));
  }
};
var Ie = class {
  constructor(n, t) {
    __publicField(this, "client");
    __publicField(this, "opts");
    __publicField(this, "enableTelemetry");
    __publicField(this, "enableAutoPipelining");
    __publicField(this, "use", (n) => {
      let t = this.client.request.bind(this.client);
      this.client.request = (o2) => n(o2, t);
    });
    __publicField(this, "addTelemetry", (n) => {
      if (this.enableTelemetry)
        try {
          this.client.mergeTelemetry(n);
        } catch {
        }
    });
    __publicField(this, "pipeline", () => new we({ client: this.client, commandOptions: this.opts, multiExec: false }));
    __publicField(this, "autoPipeline", () => Se(this));
    __publicField(this, "multi", () => new we({ client: this.client, commandOptions: this.opts, multiExec: true }));
    __publicField(this, "bitfield", (...n) => new f(n, this.client, this.opts));
    __publicField(this, "append", (...n) => new g(n, this.opts).exec(this.client));
    __publicField(this, "bitcount", (...n) => new x(n, this.opts).exec(this.client));
    __publicField(this, "bitop", (n, t, o2, ...m) => new y([n, t, o2, ...m], this.opts).exec(this.client));
    __publicField(this, "bitpos", (...n) => new b(n, this.opts).exec(this.client));
    __publicField(this, "copy", (...n) => new T(n, this.opts).exec(this.client));
    __publicField(this, "dbsize", () => new O(this.opts).exec(this.client));
    __publicField(this, "decr", (...n) => new w(n, this.opts).exec(this.client));
    __publicField(this, "decrby", (...n) => new D(n, this.opts).exec(this.client));
    __publicField(this, "del", (...n) => new A(n, this.opts).exec(this.client));
    __publicField(this, "echo", (...n) => new k(n, this.opts).exec(this.client));
    __publicField(this, "eval", (...n) => new R(n, this.opts).exec(this.client));
    __publicField(this, "evalsha", (...n) => new S(n, this.opts).exec(this.client));
    __publicField(this, "exists", (...n) => new E(n, this.opts).exec(this.client));
    __publicField(this, "expire", (...n) => new M(n, this.opts).exec(this.client));
    __publicField(this, "expireat", (...n) => new v(n, this.opts).exec(this.client));
    __publicField(this, "flushall", (n) => new P(n, this.opts).exec(this.client));
    __publicField(this, "flushdb", (...n) => new I(n, this.opts).exec(this.client));
    __publicField(this, "geoadd", (...n) => new N(n, this.opts).exec(this.client));
    __publicField(this, "geopos", (...n) => new G(n, this.opts).exec(this.client));
    __publicField(this, "geodist", (...n) => new L(n, this.opts).exec(this.client));
    __publicField(this, "geohash", (...n) => new z(n, this.opts).exec(this.client));
    __publicField(this, "geosearch", (...n) => new K(n, this.opts).exec(this.client));
    __publicField(this, "geosearchstore", (...n) => new X(n, this.opts).exec(this.client));
    __publicField(this, "get", (...n) => new U(n, this.opts).exec(this.client));
    __publicField(this, "getbit", (...n) => new J(n, this.opts).exec(this.client));
    __publicField(this, "getdel", (...n) => new B(n, this.opts).exec(this.client));
    __publicField(this, "getrange", (...n) => new Z(n, this.opts).exec(this.client));
    __publicField(this, "getset", (n, t) => new H([n, t], this.opts).exec(this.client));
    __publicField(this, "hdel", (...n) => new F(n, this.opts).exec(this.client));
    __publicField(this, "hexists", (...n) => new $(n, this.opts).exec(this.client));
    __publicField(this, "hget", (...n) => new q(n, this.opts).exec(this.client));
    __publicField(this, "hgetall", (...n) => new j(n, this.opts).exec(this.client));
    __publicField(this, "hincrby", (...n) => new Y(n, this.opts).exec(this.client));
    __publicField(this, "hincrbyfloat", (...n) => new V(n, this.opts).exec(this.client));
    __publicField(this, "hkeys", (...n) => new _(n, this.opts).exec(this.client));
    __publicField(this, "hlen", (...n) => new W(n, this.opts).exec(this.client));
    __publicField(this, "hmget", (...n) => new Q(n, this.opts).exec(this.client));
    __publicField(this, "hmset", (n, t) => new nn([n, t], this.opts).exec(this.client));
    __publicField(this, "hrandfield", (n, t, o2) => new tn([n, t, o2], this.opts).exec(this.client));
    __publicField(this, "hscan", (...n) => new en(n, this.opts).exec(this.client));
    __publicField(this, "hset", (n, t) => new on([n, t], this.opts).exec(this.client));
    __publicField(this, "hsetnx", (n, t, o2) => new sn([n, t, o2], this.opts).exec(this.client));
    __publicField(this, "hstrlen", (...n) => new mn(n, this.opts).exec(this.client));
    __publicField(this, "hvals", (...n) => new rn(n, this.opts).exec(this.client));
    __publicField(this, "incr", (...n) => new an(n, this.opts).exec(this.client));
    __publicField(this, "incrby", (...n) => new pn(n, this.opts).exec(this.client));
    __publicField(this, "incrbyfloat", (...n) => new dn(n, this.opts).exec(this.client));
    __publicField(this, "keys", (...n) => new Pn(n, this.opts).exec(this.client));
    __publicField(this, "lindex", (...n) => new In(n, this.opts).exec(this.client));
    __publicField(this, "linsert", (n, t, o2, m) => new Nn([n, t, o2, m], this.opts).exec(this.client));
    __publicField(this, "llen", (...n) => new Ln(n, this.opts).exec(this.client));
    __publicField(this, "lmove", (...n) => new zn(n, this.opts).exec(this.client));
    __publicField(this, "lpop", (...n) => new Kn(n, this.opts).exec(this.client));
    __publicField(this, "lmpop", (...n) => new Gn(n, this.opts).exec(this.client));
    __publicField(this, "lpos", (...n) => new Xn(n, this.opts).exec(this.client));
    __publicField(this, "lpush", (n, ...t) => new Un([n, ...t], this.opts).exec(this.client));
    __publicField(this, "lpushx", (n, ...t) => new Jn([n, ...t], this.opts).exec(this.client));
    __publicField(this, "lrange", (...n) => new Bn(n, this.opts).exec(this.client));
    __publicField(this, "lrem", (n, t, o2) => new Zn([n, t, o2], this.opts).exec(this.client));
    __publicField(this, "lset", (n, t, o2) => new Hn([n, t, o2], this.opts).exec(this.client));
    __publicField(this, "ltrim", (...n) => new Fn(n, this.opts).exec(this.client));
    __publicField(this, "mget", (...n) => new $n(n, this.opts).exec(this.client));
    __publicField(this, "mset", (n) => new qn([n], this.opts).exec(this.client));
    __publicField(this, "msetnx", (n) => new jn([n], this.opts).exec(this.client));
    __publicField(this, "persist", (...n) => new Yn(n, this.opts).exec(this.client));
    __publicField(this, "pexpire", (...n) => new Vn(n, this.opts).exec(this.client));
    __publicField(this, "pexpireat", (...n) => new _n(n, this.opts).exec(this.client));
    __publicField(this, "pfadd", (...n) => new Wn(n, this.opts).exec(this.client));
    __publicField(this, "pfcount", (...n) => new Qn(n, this.opts).exec(this.client));
    __publicField(this, "pfmerge", (...n) => new nt(n, this.opts).exec(this.client));
    __publicField(this, "ping", (n) => new tt(n, this.opts).exec(this.client));
    __publicField(this, "psetex", (n, t, o2) => new et([n, t, o2], this.opts).exec(this.client));
    __publicField(this, "pttl", (...n) => new ot(n, this.opts).exec(this.client));
    __publicField(this, "publish", (...n) => new st(n, this.opts).exec(this.client));
    __publicField(this, "randomkey", () => new mt().exec(this.client));
    __publicField(this, "rename", (...n) => new rt(n, this.opts).exec(this.client));
    __publicField(this, "renamenx", (...n) => new at(n, this.opts).exec(this.client));
    __publicField(this, "rpop", (...n) => new it(n, this.opts).exec(this.client));
    __publicField(this, "rpush", (n, ...t) => new pt([n, ...t], this.opts).exec(this.client));
    __publicField(this, "rpushx", (n, ...t) => new dt([n, ...t], this.opts).exec(this.client));
    __publicField(this, "sadd", (n, ...t) => new ct([n, ...t], this.opts).exec(this.client));
    __publicField(this, "scan", (...n) => new ut(n, this.opts).exec(this.client));
    __publicField(this, "scard", (...n) => new ht(n, this.opts).exec(this.client));
    __publicField(this, "scriptExists", (...n) => new lt(n, this.opts).exec(this.client));
    __publicField(this, "scriptFlush", (...n) => new Ct(n, this.opts).exec(this.client));
    __publicField(this, "scriptLoad", (...n) => new gt(n, this.opts).exec(this.client));
    __publicField(this, "sdiff", (...n) => new xt(n, this.opts).exec(this.client));
    __publicField(this, "sdiffstore", (...n) => new ft(n, this.opts).exec(this.client));
    __publicField(this, "set", (n, t, o2) => new yt([n, t, o2], this.opts).exec(this.client));
    __publicField(this, "setbit", (...n) => new bt(n, this.opts).exec(this.client));
    __publicField(this, "setex", (n, t, o2) => new Tt([n, t, o2], this.opts).exec(this.client));
    __publicField(this, "setnx", (n, t) => new Ot([n, t], this.opts).exec(this.client));
    __publicField(this, "setrange", (...n) => new wt(n, this.opts).exec(this.client));
    __publicField(this, "sinter", (...n) => new Dt(n, this.opts).exec(this.client));
    __publicField(this, "sinterstore", (...n) => new At(n, this.opts).exec(this.client));
    __publicField(this, "sismember", (n, t) => new kt([n, t], this.opts).exec(this.client));
    __publicField(this, "smismember", (n, t) => new St([n, t], this.opts).exec(this.client));
    __publicField(this, "smembers", (...n) => new Rt(n, this.opts).exec(this.client));
    __publicField(this, "smove", (n, t, o2) => new Et([n, t, o2], this.opts).exec(this.client));
    __publicField(this, "spop", (...n) => new Mt(n, this.opts).exec(this.client));
    __publicField(this, "srandmember", (...n) => new vt(n, this.opts).exec(this.client));
    __publicField(this, "srem", (n, ...t) => new Pt([n, ...t], this.opts).exec(this.client));
    __publicField(this, "sscan", (...n) => new It(n, this.opts).exec(this.client));
    __publicField(this, "strlen", (...n) => new Nt(n, this.opts).exec(this.client));
    __publicField(this, "sunion", (...n) => new Lt(n, this.opts).exec(this.client));
    __publicField(this, "sunionstore", (...n) => new zt(n, this.opts).exec(this.client));
    __publicField(this, "time", () => new Gt().exec(this.client));
    __publicField(this, "touch", (...n) => new Kt(n, this.opts).exec(this.client));
    __publicField(this, "ttl", (...n) => new Xt(n, this.opts).exec(this.client));
    __publicField(this, "type", (...n) => new Ut(n, this.opts).exec(this.client));
    __publicField(this, "unlink", (...n) => new Jt(n, this.opts).exec(this.client));
    __publicField(this, "xadd", (...n) => new Zt(n, this.opts).exec(this.client));
    __publicField(this, "xack", (...n) => new Bt(n, this.opts).exec(this.client));
    __publicField(this, "xdel", (...n) => new $t(n, this.opts).exec(this.client));
    __publicField(this, "xgroup", (...n) => new qt(n, this.opts).exec(this.client));
    __publicField(this, "xread", (...n) => new Wt(n, this.opts).exec(this.client));
    __publicField(this, "xreadgroup", (...n) => new Qt(n, this.opts).exec(this.client));
    __publicField(this, "xinfo", (...n) => new jt(n, this.opts).exec(this.client));
    __publicField(this, "xlen", (...n) => new Yt(n, this.opts).exec(this.client));
    __publicField(this, "xpending", (...n) => new Vt(n, this.opts).exec(this.client));
    __publicField(this, "xclaim", (...n) => new Ft(n, this.opts).exec(this.client));
    __publicField(this, "xautoclaim", (...n) => new Ht(n, this.opts).exec(this.client));
    __publicField(this, "xtrim", (...n) => new te(n, this.opts).exec(this.client));
    __publicField(this, "xrange", (...n) => new _t(n, this.opts).exec(this.client));
    __publicField(this, "xrevrange", (...n) => new ne(n, this.opts).exec(this.client));
    __publicField(this, "zadd", (...n) => "score" in n[1] ? new l([n[0], n[1], ...n.slice(2)], this.opts).exec(this.client) : new l([n[0], n[1], ...n.slice(2)], this.opts).exec(this.client));
    __publicField(this, "zcard", (...n) => new ee(n, this.opts).exec(this.client));
    __publicField(this, "zcount", (...n) => new oe(n, this.opts).exec(this.client));
    __publicField(this, "zdiffstore", (...n) => new be(n, this.opts).exec(this.client));
    __publicField(this, "zincrby", (n, t, o2) => new se([n, t, o2], this.opts).exec(this.client));
    __publicField(this, "zinterstore", (...n) => new me(n, this.opts).exec(this.client));
    __publicField(this, "zlexcount", (...n) => new re(n, this.opts).exec(this.client));
    __publicField(this, "zmscore", (...n) => new Te(n, this.opts).exec(this.client));
    __publicField(this, "zpopmax", (...n) => new ae(n, this.opts).exec(this.client));
    __publicField(this, "zpopmin", (...n) => new ie(n, this.opts).exec(this.client));
    __publicField(this, "zrange", (...n) => new pe(n, this.opts).exec(this.client));
    __publicField(this, "zrank", (n, t) => new de([n, t], this.opts).exec(this.client));
    __publicField(this, "zrem", (n, ...t) => new ce([n, ...t], this.opts).exec(this.client));
    __publicField(this, "zremrangebylex", (...n) => new ue(n, this.opts).exec(this.client));
    __publicField(this, "zremrangebyrank", (...n) => new he(n, this.opts).exec(this.client));
    __publicField(this, "zremrangebyscore", (...n) => new le(n, this.opts).exec(this.client));
    __publicField(this, "zrevrank", (n, t) => new Ce([n, t], this.opts).exec(this.client));
    __publicField(this, "zscan", (...n) => new ge(n, this.opts).exec(this.client));
    __publicField(this, "zscore", (n, t) => new xe([n, t], this.opts).exec(this.client));
    __publicField(this, "zunion", (...n) => new fe(n, this.opts).exec(this.client));
    __publicField(this, "zunionstore", (...n) => new ye(n, this.opts).exec(this.client));
    this.client = n, this.opts = t, this.enableTelemetry = (t == null ? void 0 : t.enableTelemetry) ?? true, this.enableAutoPipelining = (t == null ? void 0 : t.enableAutoPipelining) ?? false;
  }
  get json() {
    return { arrappend: (...n) => new cn(n, this.opts).exec(this.client), arrindex: (...n) => new un(n, this.opts).exec(this.client), arrinsert: (...n) => new hn(n, this.opts).exec(this.client), arrlen: (...n) => new ln(n, this.opts).exec(this.client), arrpop: (...n) => new Cn(n, this.opts).exec(this.client), arrtrim: (...n) => new gn(n, this.opts).exec(this.client), clear: (...n) => new xn(n, this.opts).exec(this.client), del: (...n) => new fn(n, this.opts).exec(this.client), forget: (...n) => new yn(n, this.opts).exec(this.client), get: (...n) => new bn(n, this.opts).exec(this.client), mget: (...n) => new Tn(n, this.opts).exec(this.client), numincrby: (...n) => new On(n, this.opts).exec(this.client), nummultby: (...n) => new wn(n, this.opts).exec(this.client), objkeys: (...n) => new Dn(n, this.opts).exec(this.client), objlen: (...n) => new An(n, this.opts).exec(this.client), resp: (...n) => new kn(n, this.opts).exec(this.client), set: (...n) => new Rn(n, this.opts).exec(this.client), strappend: (...n) => new Sn(n, this.opts).exec(this.client), strlen: (...n) => new En(n, this.opts).exec(this.client), toggle: (...n) => new Mn(n, this.opts).exec(this.client), type: (...n) => new vn(n, this.opts).exec(this.client) };
  }
  createScript(n) {
    return new Ae(this, n);
  }
};
var tg = "v1.32.0";

// node_modules/@upstash/redis/nodejs.mjs
typeof atob > "u" && (global.atob = (o2) => Buffer.from(o2, "base64").toString("utf-8"));
var a = class o extends Ie {
  constructor(e2) {
    if ("request" in e2) {
      super(e2);
      return;
    }
    if (!e2.url)
      throw new Error("[Upstash Redis] The 'url' property is missing or undefined in your Redis config.");
    if (!e2.token)
      throw new Error("[Upstash Redis] The 'token' property is missing or undefined in your Redis config.");
    (e2.url.startsWith(" ") || e2.url.endsWith(" ") || /\r|\n/.test(e2.url)) && console.warn("The redis url contains whitespace or newline, which can cause errors!"), (e2.token.startsWith(" ") || e2.token.endsWith(" ") || /\r|\n/.test(e2.token)) && console.warn("The redis token contains whitespace or newline, which can cause errors!");
    let n = new Me({ baseUrl: e2.url, retry: e2.retry, headers: { authorization: `Bearer ${e2.token}` }, agent: e2.agent, responseEncoding: e2.responseEncoding, cache: e2.cache || "no-store", signal: e2.signal, keepAlive: e2.keepAlive });
    if (super(n, { automaticDeserialization: e2.automaticDeserialization, enableTelemetry: !process.env.UPSTASH_DISABLE_TELEMETRY, latencyLogging: e2.latencyLogging, enableAutoPipelining: e2.enableAutoPipelining }), this.addTelemetry({ runtime: typeof EdgeRuntime == "string" ? "edge-light" : `node@${process.version}`, platform: process.env.VERCEL ? "vercel" : process.env.AWS_REGION ? "aws" : "unknown", sdk: `@upstash/redis@${tg}` }), this.enableAutoPipelining)
      return this.autoPipeline();
  }
  static fromEnv(e2) {
    if (typeof (process == null ? void 0 : process.env) > "u")
      throw new Error('Unable to get environment variables, `process.env` is undefined. If you are deploying to cloudflare, please import from "@upstash/redis/cloudflare" instead');
    let n = process == null ? void 0 : process.env.UPSTASH_REDIS_REST_URL;
    if (!n)
      throw new Error("Unable to find environment variable: `UPSTASH_REDIS_REST_URL`");
    let t = process == null ? void 0 : process.env.UPSTASH_REDIS_REST_TOKEN;
    if (!t)
      throw new Error("Unable to find environment variable: `UPSTASH_REDIS_REST_TOKEN`");
    return new o({ ...e2, url: n, token: t });
  }
};

// node_modules/@vercel/kv/dist/index.js
var _kv = null;
process.env.UPSTASH_DISABLE_TELEMETRY = "1";
var VercelKV = class extends a {
  // This API is based on https://github.com/redis/node-redis#scan-iterator which is not supported in @upstash/redis
  /**
   * Same as `scan` but returns an AsyncIterator to allow iteration via `for await`.
   */
  async *scanIterator(options) {
    let cursor = 0;
    let keys;
    do {
      [cursor, keys] = await this.scan(cursor, options);
      for (const key of keys) {
        yield key;
      }
    } while (cursor !== 0);
  }
  /**
   * Same as `hscan` but returns an AsyncIterator to allow iteration via `for await`.
   */
  async *hscanIterator(key, options) {
    let cursor = 0;
    let items;
    do {
      [cursor, items] = await this.hscan(key, cursor, options);
      for (const item of items) {
        yield item;
      }
    } while (cursor !== 0);
  }
  /**
   * Same as `sscan` but returns an AsyncIterator to allow iteration via `for await`.
   */
  async *sscanIterator(key, options) {
    let cursor = 0;
    let items;
    do {
      [cursor, items] = await this.sscan(key, cursor, options);
      for (const item of items) {
        yield item;
      }
    } while (cursor !== 0);
  }
  /**
   * Same as `zscan` but returns an AsyncIterator to allow iteration via `for await`.
   */
  async *zscanIterator(key, options) {
    let cursor = 0;
    let items;
    do {
      [cursor, items] = await this.zscan(key, cursor, options);
      for (const item of items) {
        yield item;
      }
    } while (cursor !== 0);
  }
};
function createClient(config) {
  return new VercelKV({
    // The Next.js team recommends no value or `default` for fetch requests's `cache` option
    // upstash/redis defaults to `no-store`, so we enforce `default`
    cache: "default",
    enableAutoPipelining: true,
    ...config
  });
}
var src_default = new Proxy(
  {},
  {
    get(target, prop, receiver) {
      if (prop === "then" || prop === "parse") {
        return Reflect.get(target, prop, receiver);
      }
      if (!_kv) {
        if (!process.env.KV_REST_API_URL || !process.env.KV_REST_API_TOKEN) {
          throw new Error(
            "@vercel/kv: Missing required environment variables KV_REST_API_URL and KV_REST_API_TOKEN"
          );
        }
        console.warn(
          '\x1B[33m"The default export has been moved to a named export and it will be removed in version 1, change to import { kv }\x1B[0m"'
        );
        _kv = createClient({
          url: process.env.KV_REST_API_URL,
          token: process.env.KV_REST_API_TOKEN
        });
      }
      return Reflect.get(_kv, prop);
    }
  }
);
var kv = new Proxy(
  {},
  {
    get(target, prop) {
      if (!_kv) {
        if (!process.env.KV_REST_API_URL || !process.env.KV_REST_API_TOKEN) {
          throw new Error(
            "@vercel/kv: Missing required environment variables KV_REST_API_URL and KV_REST_API_TOKEN"
          );
        }
        _kv = createClient({
          url: process.env.KV_REST_API_URL,
          token: process.env.KV_REST_API_TOKEN
        });
      }
      return Reflect.get(_kv, prop);
    }
  }
);
export {
  VercelKV,
  createClient,
  src_default as default,
  kv
};
//# sourceMappingURL=@vercel_kv.js.map
